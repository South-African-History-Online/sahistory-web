<?php

/**
 * @file
 * Primary module hooks for SAHO Upcoming Events module.
 */

/**
 * Implements hook_help().
 */
function saho_upcoming_events_help($route_name) {
  switch ($route_name) {
    case 'help.page.saho_upcoming_events':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The SAHO Upcoming Events module provides functionality to display upcoming events on the front page.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_theme().
 */
function saho_upcoming_events_theme() {
  return [
    'saho_upcoming_events_block' => [
      'variables' => [
        'events' => [],
        'config' => [],
      ],
      'template' => 'saho-upcoming-events-block',
    ],
  ];
}

/**
 * Implements hook_preprocess_HOOK() for views_view.
 */
function saho_upcoming_events_preprocess_views_view(&$variables) {
  $view = $variables['view'];

  // Add CSS for all upcoming events view.
  if ($view->id() == 'all_upcoming_events') {
    $variables['#attached']['library'][] = 'saho_upcoming_events/upcoming_events';

    // Separate events into upcoming and past.
    // Use start of today in SAST timezone for comparison.
    $current_date = new \DateTime('today', new \DateTimeZone('Africa/Johannesburg'));
    $upcoming_events = [];
    $past_events = [];

    $view_builder = \Drupal::entityTypeManager()->getViewBuilder('node');
    $renderer = \Drupal::service('renderer');

    foreach ($view->result as $row) {
      $node = $row->_entity;
      if ($node && $node->hasField('field_start_date') && !$node->get('field_start_date')->isEmpty()) {
        $start_date = $node->get('field_start_date')->date;

        // Skip if start_date is null.
        if (!$start_date) {
          continue;
        }

        $end_date = NULL;
        if ($node->hasField('field_end_date') && !$node->get('field_end_date')->isEmpty()) {
          $end_date = $node->get('field_end_date')->date;
        }

        // Determine the effective end date for categorization.
        // If end_date exists, use it. Otherwise, use start_date.
        $effective_end_date = $end_date ? $end_date : $start_date;
        $effective_end_date->setTimezone(new \DateTimeZone('Africa/Johannesburg'));
        $effective_end_date_only = new \DateTime($effective_end_date->format('Y-m-d'), new \DateTimeZone('Africa/Johannesburg'));

        // Convert start date to date-only for comparison.
        $start_date_only = new \DateTime($start_date->format('Y-m-d'), new \DateTimeZone('Africa/Johannesburg'));

        // Render the node in teaser view mode.
        $build = $view_builder->view($node, 'teaser');
        $rendered = $renderer->render($build);

        // Determine if event is happening now or upcoming.
        $is_happening_now = ($start_date_only <= $current_date && $effective_end_date_only >= $current_date);

        // Store with start date timestamp and status for sorting.
        $event_data = [
          'timestamp' => $start_date->getTimestamp(),
          'is_happening_now' => $is_happening_now,
          'markup' => ['#markup' => $rendered],
        ];

        // Event is upcoming/current if end date is today or in the future.
        if ($effective_end_date_only >= $current_date) {
          $upcoming_events[] = $event_data;
        }
        else {
          $past_events[] = $event_data;
        }
      }
    }

    // Sort upcoming events: happening now first, then by start date.
    usort($upcoming_events, function ($a, $b) {
      // Happening now events come first.
      if ($a['is_happening_now'] && !$b['is_happening_now']) {
        return -1;
      }
      if (!$a['is_happening_now'] && $b['is_happening_now']) {
        return 1;
      }
      // Within same category, sort by start date.
      return $a['timestamp'] <=> $b['timestamp'];
    });

    // Sort past events reverse chronologically (most recent first).
    usort($past_events, function ($a, $b) {
      return $b['timestamp'] <=> $a['timestamp'];
    });

    // Extract just the markup for rendering.
    $upcoming_rows = array_column($upcoming_events, 'markup');
    $past_rows = array_column($past_events, 'markup');

    $variables['upcoming_events'] = $upcoming_rows;
    $variables['past_events'] = $past_rows;
    $variables['has_upcoming'] = !empty($upcoming_rows);
    $variables['has_past'] = !empty($past_rows);
  }
}

/**
 * Implements hook_preprocess_HOOK() for node.
 */
function saho_upcoming_events_preprocess_node(&$variables) {
  $node = $variables['node'];

  // Add event status for upcoming events.
  if ($node->getType() === 'upcomingevent' && $variables['view_mode'] === 'teaser') {
    // Use start of today in SAST timezone for comparison.
    $current_date = new \DateTime('today', new \DateTimeZone('Africa/Johannesburg'));

    if ($node->hasField('field_start_date') && !$node->get('field_start_date')->isEmpty()) {
      $start_date = $node->get('field_start_date')->date;

      // Skip if start_date is null.
      if (!$start_date) {
        return;
      }

      $end_date = NULL;
      if ($node->hasField('field_end_date') && !$node->get('field_end_date')->isEmpty()) {
        $end_date = $node->get('field_end_date')->date;
      }

      // Convert dates to SAST timezone for date-only comparison.
      $start_date->setTimezone(new \DateTimeZone('Africa/Johannesburg'));
      $start_date_only = new \DateTime($start_date->format('Y-m-d'), new \DateTimeZone('Africa/Johannesburg'));

      // Determine the effective end date for status calculation.
      // If end_date exists, use it. Otherwise, use start_date.
      $effective_end_date = $end_date ? $end_date : $start_date;
      $effective_end_date->setTimezone(new \DateTimeZone('Africa/Johannesburg'));
      $effective_end_date_only = new \DateTime($effective_end_date->format('Y-m-d'), new \DateTimeZone('Africa/Johannesburg'));

      // Determine event status using date-only comparison.
      if ($start_date_only > $current_date) {
        // Event hasn't started yet.
        $variables['event_status'] = 'upcoming';
        $variables['event_status_label'] = t('Upcoming');

        // Calculate days until event.
        $interval = $current_date->diff($start_date_only);
        $days = $interval->days;

        if ($days === 0) {
          $variables['countdown'] = t('Today');
        }
        elseif ($days === 1) {
          $variables['countdown'] = t('Tomorrow');
        }
        elseif ($days <= 30) {
          $variables['countdown'] = t('In @days days', ['@days' => $days]);
        }
      }
      elseif ($effective_end_date_only >= $current_date) {
        // Event has started and is still ongoing.
        $variables['event_status'] = 'in-progress';
        $variables['event_status_label'] = t('Happening Now');
      }
      else {
        // Event has ended.
        $variables['event_status'] = 'past';
        $variables['event_status_label'] = t('Past Event');
      }
    }
  }
}
